// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `longhorn.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:models.LonghornDisk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LonghornDisk {
    // message fields
    // @@protoc_insertion_point(field:models.LonghornDisk.diskUUID)
    pub diskUUID: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornDisk.allowScheduling)
    pub allowScheduling: bool,
    // @@protoc_insertion_point(field:models.LonghornDisk.evictionRequested)
    pub evictionRequested: bool,
    // @@protoc_insertion_point(field:models.LonghornDisk.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornDisk.storageAvailable)
    pub storageAvailable: u64,
    // @@protoc_insertion_point(field:models.LonghornDisk.storageMaximum)
    pub storageMaximum: u64,
    // @@protoc_insertion_point(field:models.LonghornDisk.storageReserved)
    pub storageReserved: u64,
    // @@protoc_insertion_point(field:models.LonghornDisk.storageScheduled)
    pub storageScheduled: u64,
    // @@protoc_insertion_point(field:models.LonghornDisk.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:models.LonghornDisk.conditions)
    pub conditions: ::protobuf::MessageField<ConditionsBlock>,
    // @@protoc_insertion_point(field:models.LonghornDisk.scheduledReplica)
    pub scheduledReplica: ::std::collections::HashMap<::std::string::String, u64>,
    // special fields
    // @@protoc_insertion_point(special_field:models.LonghornDisk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LonghornDisk {
    fn default() -> &'a LonghornDisk {
        <LonghornDisk as ::protobuf::Message>::default_instance()
    }
}

impl LonghornDisk {
    pub fn new() -> LonghornDisk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "diskUUID",
            |m: &LonghornDisk| { &m.diskUUID },
            |m: &mut LonghornDisk| { &mut m.diskUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowScheduling",
            |m: &LonghornDisk| { &m.allowScheduling },
            |m: &mut LonghornDisk| { &mut m.allowScheduling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evictionRequested",
            |m: &LonghornDisk| { &m.evictionRequested },
            |m: &mut LonghornDisk| { &mut m.evictionRequested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &LonghornDisk| { &m.path },
            |m: &mut LonghornDisk| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "storageAvailable",
            |m: &LonghornDisk| { &m.storageAvailable },
            |m: &mut LonghornDisk| { &mut m.storageAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "storageMaximum",
            |m: &LonghornDisk| { &m.storageMaximum },
            |m: &mut LonghornDisk| { &mut m.storageMaximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "storageReserved",
            |m: &LonghornDisk| { &m.storageReserved },
            |m: &mut LonghornDisk| { &mut m.storageReserved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "storageScheduled",
            |m: &LonghornDisk| { &m.storageScheduled },
            |m: &mut LonghornDisk| { &mut m.storageScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &LonghornDisk| { &m.tags },
            |m: &mut LonghornDisk| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConditionsBlock>(
            "conditions",
            |m: &LonghornDisk| { &m.conditions },
            |m: &mut LonghornDisk| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "scheduledReplica",
            |m: &LonghornDisk| { &m.scheduledReplica },
            |m: &mut LonghornDisk| { &mut m.scheduledReplica },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LonghornDisk>(
            "LonghornDisk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LonghornDisk {
    const NAME: &'static str = "LonghornDisk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diskUUID = is.read_string()?;
                },
                16 => {
                    self.allowScheduling = is.read_bool()?;
                },
                24 => {
                    self.evictionRequested = is.read_bool()?;
                },
                34 => {
                    self.path = is.read_string()?;
                },
                40 => {
                    self.storageAvailable = is.read_uint64()?;
                },
                48 => {
                    self.storageMaximum = is.read_uint64()?;
                },
                56 => {
                    self.storageReserved = is.read_uint64()?;
                },
                64 => {
                    self.storageScheduled = is.read_uint64()?;
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.conditions)?;
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_uint64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.scheduledReplica.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.diskUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.diskUUID);
        }
        if self.allowScheduling != false {
            my_size += 1 + 1;
        }
        if self.evictionRequested != false {
            my_size += 1 + 1;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.path);
        }
        if self.storageAvailable != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.storageAvailable);
        }
        if self.storageMaximum != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.storageMaximum);
        }
        if self.storageReserved != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.storageReserved);
        }
        if self.storageScheduled != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.storageScheduled);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.scheduledReplica {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::uint64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.diskUUID.is_empty() {
            os.write_string(1, &self.diskUUID)?;
        }
        if self.allowScheduling != false {
            os.write_bool(2, self.allowScheduling)?;
        }
        if self.evictionRequested != false {
            os.write_bool(3, self.evictionRequested)?;
        }
        if !self.path.is_empty() {
            os.write_string(4, &self.path)?;
        }
        if self.storageAvailable != 0 {
            os.write_uint64(5, self.storageAvailable)?;
        }
        if self.storageMaximum != 0 {
            os.write_uint64(6, self.storageMaximum)?;
        }
        if self.storageReserved != 0 {
            os.write_uint64(7, self.storageReserved)?;
        }
        if self.storageScheduled != 0 {
            os.write_uint64(8, self.storageScheduled)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for (k, v) in &self.scheduledReplica {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::uint64_size(2, *v);
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LonghornDisk {
        LonghornDisk::new()
    }

    fn clear(&mut self) {
        self.diskUUID.clear();
        self.allowScheduling = false;
        self.evictionRequested = false;
        self.path.clear();
        self.storageAvailable = 0;
        self.storageMaximum = 0;
        self.storageReserved = 0;
        self.storageScheduled = 0;
        self.tags.clear();
        self.conditions.clear();
        self.scheduledReplica.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LonghornDisk {
        static instance: ::protobuf::rt::Lazy<LonghornDisk> = ::protobuf::rt::Lazy::new();
        instance.get(LonghornDisk::new)
    }
}

impl ::protobuf::MessageFull for LonghornDisk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LonghornDisk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LonghornDisk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LonghornDisk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.LonghornNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LonghornNode {
    // message fields
    // @@protoc_insertion_point(field:models.LonghornNode.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNode.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNode.zone)
    pub zone: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNode.region)
    pub region: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNode.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:models.LonghornNode.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNode.allowScheduling)
    pub allowScheduling: bool,
    // @@protoc_insertion_point(field:models.LonghornNode.engineManagerCPURequest)
    pub engineManagerCPURequest: i32,
    // @@protoc_insertion_point(field:models.LonghornNode.replicaManagerCPURequest)
    pub replicaManagerCPURequest: i32,
    // @@protoc_insertion_point(field:models.LonghornNode.evictionRequested)
    pub evictionRequested: bool,
    // @@protoc_insertion_point(field:models.LonghornNode.disks)
    pub disks: ::std::collections::HashMap<::std::string::String, LonghornDisk>,
    // @@protoc_insertion_point(field:models.LonghornNode.actions)
    pub actions: ::protobuf::MessageField<Actions>,
    // special fields
    // @@protoc_insertion_point(special_field:models.LonghornNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LonghornNode {
    fn default() -> &'a LonghornNode {
        <LonghornNode as ::protobuf::Message>::default_instance()
    }
}

impl LonghornNode {
    pub fn new() -> LonghornNode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &LonghornNode| { &m.id },
            |m: &mut LonghornNode| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LonghornNode| { &m.name },
            |m: &mut LonghornNode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zone",
            |m: &LonghornNode| { &m.zone },
            |m: &mut LonghornNode| { &mut m.zone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "region",
            |m: &LonghornNode| { &m.region },
            |m: &mut LonghornNode| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &LonghornNode| { &m.tags },
            |m: &mut LonghornNode| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &LonghornNode| { &m.address },
            |m: &mut LonghornNode| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowScheduling",
            |m: &LonghornNode| { &m.allowScheduling },
            |m: &mut LonghornNode| { &mut m.allowScheduling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "engineManagerCPURequest",
            |m: &LonghornNode| { &m.engineManagerCPURequest },
            |m: &mut LonghornNode| { &mut m.engineManagerCPURequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replicaManagerCPURequest",
            |m: &LonghornNode| { &m.replicaManagerCPURequest },
            |m: &mut LonghornNode| { &mut m.replicaManagerCPURequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evictionRequested",
            |m: &LonghornNode| { &m.evictionRequested },
            |m: &mut LonghornNode| { &mut m.evictionRequested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "disks",
            |m: &LonghornNode| { &m.disks },
            |m: &mut LonghornNode| { &mut m.disks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Actions>(
            "actions",
            |m: &LonghornNode| { &m.actions },
            |m: &mut LonghornNode| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LonghornNode>(
            "LonghornNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LonghornNode {
    const NAME: &'static str = "LonghornNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.zone = is.read_string()?;
                },
                34 => {
                    self.region = is.read_string()?;
                },
                42 => {
                    self.tags.push(is.read_string()?);
                },
                50 => {
                    self.address = is.read_string()?;
                },
                56 => {
                    self.allowScheduling = is.read_bool()?;
                },
                64 => {
                    self.engineManagerCPURequest = is.read_int32()?;
                },
                72 => {
                    self.replicaManagerCPURequest = is.read_int32()?;
                },
                80 => {
                    self.evictionRequested = is.read_bool()?;
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.disks.insert(key, value);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.zone);
        }
        if !self.region.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.region);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.address);
        }
        if self.allowScheduling != false {
            my_size += 1 + 1;
        }
        if self.engineManagerCPURequest != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.engineManagerCPURequest);
        }
        if self.replicaManagerCPURequest != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.replicaManagerCPURequest);
        }
        if self.evictionRequested != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.disks {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.zone.is_empty() {
            os.write_string(3, &self.zone)?;
        }
        if !self.region.is_empty() {
            os.write_string(4, &self.region)?;
        }
        for v in &self.tags {
            os.write_string(5, &v)?;
        };
        if !self.address.is_empty() {
            os.write_string(6, &self.address)?;
        }
        if self.allowScheduling != false {
            os.write_bool(7, self.allowScheduling)?;
        }
        if self.engineManagerCPURequest != 0 {
            os.write_int32(8, self.engineManagerCPURequest)?;
        }
        if self.replicaManagerCPURequest != 0 {
            os.write_int32(9, self.replicaManagerCPURequest)?;
        }
        if self.evictionRequested != false {
            os.write_bool(10, self.evictionRequested)?;
        }
        for (k, v) in &self.disks {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.actions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LonghornNode {
        LonghornNode::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.zone.clear();
        self.region.clear();
        self.tags.clear();
        self.address.clear();
        self.allowScheduling = false;
        self.engineManagerCPURequest = 0;
        self.replicaManagerCPURequest = 0;
        self.evictionRequested = false;
        self.disks.clear();
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LonghornNode {
        static instance: ::protobuf::rt::Lazy<LonghornNode> = ::protobuf::rt::Lazy::new();
        instance.get(LonghornNode::new)
    }
}

impl ::protobuf::MessageFull for LonghornNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LonghornNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LonghornNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LonghornNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.LonghornNodes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LonghornNodes {
    // message fields
    // @@protoc_insertion_point(field:models.LonghornNodes.data)
    pub data: ::std::vec::Vec<LonghornNode>,
    // @@protoc_insertion_point(field:models.LonghornNodes.links)
    pub links: ::protobuf::MessageField<Links>,
    // @@protoc_insertion_point(field:models.LonghornNodes.resourceType)
    pub resourceType: ::std::string::String,
    // @@protoc_insertion_point(field:models.LonghornNodes.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.LonghornNodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LonghornNodes {
    fn default() -> &'a LonghornNodes {
        <LonghornNodes as ::protobuf::Message>::default_instance()
    }
}

impl LonghornNodes {
    pub fn new() -> LonghornNodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &LonghornNodes| { &m.data },
            |m: &mut LonghornNodes| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Links>(
            "links",
            |m: &LonghornNodes| { &m.links },
            |m: &mut LonghornNodes| { &mut m.links },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resourceType",
            |m: &LonghornNodes| { &m.resourceType },
            |m: &mut LonghornNodes| { &mut m.resourceType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &LonghornNodes| { &m.type_ },
            |m: &mut LonghornNodes| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LonghornNodes>(
            "LonghornNodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LonghornNodes {
    const NAME: &'static str = "LonghornNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.links)?;
                },
                26 => {
                    self.resourceType = is.read_string()?;
                },
                34 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.links.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.resourceType.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.resourceType);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.links.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.resourceType.is_empty() {
            os.write_string(3, &self.resourceType)?;
        }
        if !self.type_.is_empty() {
            os.write_string(4, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LonghornNodes {
        LonghornNodes::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.links.clear();
        self.resourceType.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LonghornNodes {
        static instance: LonghornNodes = LonghornNodes {
            data: ::std::vec::Vec::new(),
            links: ::protobuf::MessageField::none(),
            resourceType: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LonghornNodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LonghornNodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LonghornNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LonghornNodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.Links)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Links {
    // message fields
    // @@protoc_insertion_point(field:models.Links.self)
    pub self_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.Links.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Links {
    fn default() -> &'a Links {
        <Links as ::protobuf::Message>::default_instance()
    }
}

impl Links {
    pub fn new() -> Links {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "self",
            |m: &Links| { &m.self_ },
            |m: &mut Links| { &mut m.self_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Links>(
            "Links",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Links {
    const NAME: &'static str = "Links";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.self_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.self_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.self_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.self_.is_empty() {
            os.write_string(1, &self.self_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Links {
        Links::new()
    }

    fn clear(&mut self) {
        self.self_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Links {
        static instance: Links = Links {
            self_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Links {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Links").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Links {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Links {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.Actions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Actions {
    // message fields
    // @@protoc_insertion_point(field:models.Actions.diskUpdate)
    pub diskUpdate: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.Actions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Actions {
    fn default() -> &'a Actions {
        <Actions as ::protobuf::Message>::default_instance()
    }
}

impl Actions {
    pub fn new() -> Actions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "diskUpdate",
            |m: &Actions| { &m.diskUpdate },
            |m: &mut Actions| { &mut m.diskUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Actions>(
            "Actions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Actions {
    const NAME: &'static str = "Actions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diskUpdate = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.diskUpdate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.diskUpdate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.diskUpdate.is_empty() {
            os.write_string(1, &self.diskUpdate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Actions {
        Actions::new()
    }

    fn clear(&mut self) {
        self.diskUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Actions {
        static instance: Actions = Actions {
            diskUpdate: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Actions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Actions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Actions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Actions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.ReadyBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReadyBlock {
    // message fields
    // @@protoc_insertion_point(field:models.ReadyBlock.lastProbeTime)
    pub lastProbeTime: ::std::string::String,
    // @@protoc_insertion_point(field:models.ReadyBlock.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:models.ReadyBlock.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:models.ReadyBlock.reason)
    pub reason: ::std::string::String,
    // @@protoc_insertion_point(field:models.ReadyBlock.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:models.ReadyBlock.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.ReadyBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadyBlock {
    fn default() -> &'a ReadyBlock {
        <ReadyBlock as ::protobuf::Message>::default_instance()
    }
}

impl ReadyBlock {
    pub fn new() -> ReadyBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastProbeTime",
            |m: &ReadyBlock| { &m.lastProbeTime },
            |m: &mut ReadyBlock| { &mut m.lastProbeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "lastTransitionTime",
            |m: &ReadyBlock| { &m.lastTransitionTime },
            |m: &mut ReadyBlock| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &ReadyBlock| { &m.message },
            |m: &mut ReadyBlock| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &ReadyBlock| { &m.reason },
            |m: &mut ReadyBlock| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ReadyBlock| { &m.status },
            |m: &mut ReadyBlock| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ReadyBlock| { &m.type_ },
            |m: &mut ReadyBlock| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadyBlock>(
            "ReadyBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadyBlock {
    const NAME: &'static str = "ReadyBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lastProbeTime = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                34 => {
                    self.reason = is.read_string()?;
                },
                42 => {
                    self.status = is.read_string()?;
                },
                82 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.lastProbeTime.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lastProbeTime);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.reason);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.status);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.lastProbeTime.is_empty() {
            os.write_string(1, &self.lastProbeTime)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if !self.reason.is_empty() {
            os.write_string(4, &self.reason)?;
        }
        if !self.status.is_empty() {
            os.write_string(5, &self.status)?;
        }
        if !self.type_.is_empty() {
            os.write_string(10, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadyBlock {
        ReadyBlock::new()
    }

    fn clear(&mut self) {
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.message.clear();
        self.reason.clear();
        self.status.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadyBlock {
        static instance: ReadyBlock = ReadyBlock {
            lastProbeTime: ::std::string::String::new(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            reason: ::std::string::String::new(),
            status: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadyBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadyBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadyBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.SchedulableBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SchedulableBlock {
    // message fields
    // @@protoc_insertion_point(field:models.SchedulableBlock.lastProbeTime)
    pub lastProbeTime: ::std::string::String,
    // @@protoc_insertion_point(field:models.SchedulableBlock.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:models.SchedulableBlock.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:models.SchedulableBlock.reason)
    pub reason: ::std::string::String,
    // @@protoc_insertion_point(field:models.SchedulableBlock.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:models.SchedulableBlock.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.SchedulableBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SchedulableBlock {
    fn default() -> &'a SchedulableBlock {
        <SchedulableBlock as ::protobuf::Message>::default_instance()
    }
}

impl SchedulableBlock {
    pub fn new() -> SchedulableBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastProbeTime",
            |m: &SchedulableBlock| { &m.lastProbeTime },
            |m: &mut SchedulableBlock| { &mut m.lastProbeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "lastTransitionTime",
            |m: &SchedulableBlock| { &m.lastTransitionTime },
            |m: &mut SchedulableBlock| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &SchedulableBlock| { &m.message },
            |m: &mut SchedulableBlock| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &SchedulableBlock| { &m.reason },
            |m: &mut SchedulableBlock| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &SchedulableBlock| { &m.status },
            |m: &mut SchedulableBlock| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &SchedulableBlock| { &m.type_ },
            |m: &mut SchedulableBlock| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SchedulableBlock>(
            "SchedulableBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SchedulableBlock {
    const NAME: &'static str = "SchedulableBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lastProbeTime = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                34 => {
                    self.reason = is.read_string()?;
                },
                42 => {
                    self.status = is.read_string()?;
                },
                50 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.lastProbeTime.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lastProbeTime);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.reason);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.status);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.lastProbeTime.is_empty() {
            os.write_string(1, &self.lastProbeTime)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if !self.reason.is_empty() {
            os.write_string(4, &self.reason)?;
        }
        if !self.status.is_empty() {
            os.write_string(5, &self.status)?;
        }
        if !self.type_.is_empty() {
            os.write_string(6, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SchedulableBlock {
        SchedulableBlock::new()
    }

    fn clear(&mut self) {
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.message.clear();
        self.reason.clear();
        self.status.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SchedulableBlock {
        static instance: SchedulableBlock = SchedulableBlock {
            lastProbeTime: ::std::string::String::new(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            reason: ::std::string::String::new(),
            status: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SchedulableBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SchedulableBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SchedulableBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulableBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.MountPropagationBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MountPropagationBlock {
    // message fields
    // @@protoc_insertion_point(field:models.MountPropagationBlock.lastProbeTime)
    pub lastProbeTime: ::std::string::String,
    // @@protoc_insertion_point(field:models.MountPropagationBlock.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:models.MountPropagationBlock.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:models.MountPropagationBlock.reason)
    pub reason: ::std::string::String,
    // @@protoc_insertion_point(field:models.MountPropagationBlock.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:models.MountPropagationBlock.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.MountPropagationBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MountPropagationBlock {
    fn default() -> &'a MountPropagationBlock {
        <MountPropagationBlock as ::protobuf::Message>::default_instance()
    }
}

impl MountPropagationBlock {
    pub fn new() -> MountPropagationBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastProbeTime",
            |m: &MountPropagationBlock| { &m.lastProbeTime },
            |m: &mut MountPropagationBlock| { &mut m.lastProbeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "lastTransitionTime",
            |m: &MountPropagationBlock| { &m.lastTransitionTime },
            |m: &mut MountPropagationBlock| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &MountPropagationBlock| { &m.message },
            |m: &mut MountPropagationBlock| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &MountPropagationBlock| { &m.reason },
            |m: &mut MountPropagationBlock| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &MountPropagationBlock| { &m.status },
            |m: &mut MountPropagationBlock| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MountPropagationBlock| { &m.type_ },
            |m: &mut MountPropagationBlock| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MountPropagationBlock>(
            "MountPropagationBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MountPropagationBlock {
    const NAME: &'static str = "MountPropagationBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lastProbeTime = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                34 => {
                    self.reason = is.read_string()?;
                },
                42 => {
                    self.status = is.read_string()?;
                },
                50 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.lastProbeTime.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lastProbeTime);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.reason);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.status);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.lastProbeTime.is_empty() {
            os.write_string(1, &self.lastProbeTime)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if !self.reason.is_empty() {
            os.write_string(4, &self.reason)?;
        }
        if !self.status.is_empty() {
            os.write_string(5, &self.status)?;
        }
        if !self.type_.is_empty() {
            os.write_string(6, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MountPropagationBlock {
        MountPropagationBlock::new()
    }

    fn clear(&mut self) {
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.message.clear();
        self.reason.clear();
        self.status.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MountPropagationBlock {
        static instance: MountPropagationBlock = MountPropagationBlock {
            lastProbeTime: ::std::string::String::new(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            reason: ::std::string::String::new(),
            status: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MountPropagationBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MountPropagationBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MountPropagationBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MountPropagationBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.ConditionsBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConditionsBlock {
    // message fields
    // @@protoc_insertion_point(field:models.ConditionsBlock.MountPropagation)
    pub MountPropagation: ::protobuf::MessageField<MountPropagationBlock>,
    // @@protoc_insertion_point(field:models.ConditionsBlock.Ready)
    pub Ready: ::protobuf::MessageField<ReadyBlock>,
    // @@protoc_insertion_point(field:models.ConditionsBlock.Schedulable)
    pub Schedulable: ::protobuf::MessageField<SchedulableBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:models.ConditionsBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConditionsBlock {
    fn default() -> &'a ConditionsBlock {
        <ConditionsBlock as ::protobuf::Message>::default_instance()
    }
}

impl ConditionsBlock {
    pub fn new() -> ConditionsBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MountPropagationBlock>(
            "MountPropagation",
            |m: &ConditionsBlock| { &m.MountPropagation },
            |m: &mut ConditionsBlock| { &mut m.MountPropagation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReadyBlock>(
            "Ready",
            |m: &ConditionsBlock| { &m.Ready },
            |m: &mut ConditionsBlock| { &mut m.Ready },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SchedulableBlock>(
            "Schedulable",
            |m: &ConditionsBlock| { &m.Schedulable },
            |m: &mut ConditionsBlock| { &mut m.Schedulable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConditionsBlock>(
            "ConditionsBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConditionsBlock {
    const NAME: &'static str = "ConditionsBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MountPropagation)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Ready)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Schedulable)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.MountPropagation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Ready.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Schedulable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.MountPropagation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.Ready.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.Schedulable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConditionsBlock {
        ConditionsBlock::new()
    }

    fn clear(&mut self) {
        self.MountPropagation.clear();
        self.Ready.clear();
        self.Schedulable.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConditionsBlock {
        static instance: ConditionsBlock = ConditionsBlock {
            MountPropagation: ::protobuf::MessageField::none(),
            Ready: ::protobuf::MessageField::none(),
            Schedulable: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConditionsBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConditionsBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConditionsBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionsBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:models.ErrorBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ErrorBlock {
    // message fields
    // @@protoc_insertion_point(field:models.ErrorBlock.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:models.ErrorBlock.detail)
    pub detail: ::std::string::String,
    // @@protoc_insertion_point(field:models.ErrorBlock.links)
    pub links: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:models.ErrorBlock.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:models.ErrorBlock.status)
    pub status: u32,
    // @@protoc_insertion_point(field:models.ErrorBlock.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:models.ErrorBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ErrorBlock {
    fn default() -> &'a ErrorBlock {
        <ErrorBlock as ::protobuf::Message>::default_instance()
    }
}

impl ErrorBlock {
    pub fn new() -> ErrorBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ErrorBlock| { &m.code },
            |m: &mut ErrorBlock| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "detail",
            |m: &ErrorBlock| { &m.detail },
            |m: &mut ErrorBlock| { &mut m.detail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "links",
            |m: &ErrorBlock| { &m.links },
            |m: &mut ErrorBlock| { &mut m.links },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &ErrorBlock| { &m.message },
            |m: &mut ErrorBlock| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ErrorBlock| { &m.status },
            |m: &mut ErrorBlock| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ErrorBlock| { &m.type_ },
            |m: &mut ErrorBlock| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorBlock>(
            "ErrorBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ErrorBlock {
    const NAME: &'static str = "ErrorBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                18 => {
                    self.detail = is.read_string()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.links.insert(key, value);
                },
                34 => {
                    self.message = is.read_string()?;
                },
                40 => {
                    self.status = is.read_uint32()?;
                },
                50 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.detail.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.detail);
        }
        for (k, v) in &self.links {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.status);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.detail.is_empty() {
            os.write_string(2, &self.detail)?;
        }
        for (k, v) in &self.links {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        if self.status != 0 {
            os.write_uint32(5, self.status)?;
        }
        if !self.type_.is_empty() {
            os.write_string(6, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ErrorBlock {
        ErrorBlock::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.detail.clear();
        self.links.clear();
        self.message.clear();
        self.status = 0;
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ErrorBlock {
        static instance: ::protobuf::rt::Lazy<ErrorBlock> = ::protobuf::rt::Lazy::new();
        instance.get(ErrorBlock::new)
    }
}

impl ::protobuf::MessageFull for ErrorBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ErrorBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ErrorBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:models.TypeBlock)
pub enum TypeBlock {
    // @@protoc_insertion_point(enum_value:models.TypeBlock.Empty)
    Empty = 0,
    // @@protoc_insertion_point(enum_value:models.TypeBlock.Ready)
    Ready = 1,
    // @@protoc_insertion_point(enum_value:models.TypeBlock.Schedulable)
    Schedulable = 2,
    // @@protoc_insertion_point(enum_value:models.TypeBlock.node)
    node = 3,
    // @@protoc_insertion_point(enum_value:models.TypeBlock.MountPropagation)
    MountPropagation = 4,
    // @@protoc_insertion_point(enum_value:models.TypeBlock.Error)
    Error = 5,
}

impl ::protobuf::Enum for TypeBlock {
    const NAME: &'static str = "TypeBlock";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeBlock> {
        match value {
            0 => ::std::option::Option::Some(TypeBlock::Empty),
            1 => ::std::option::Option::Some(TypeBlock::Ready),
            2 => ::std::option::Option::Some(TypeBlock::Schedulable),
            3 => ::std::option::Option::Some(TypeBlock::node),
            4 => ::std::option::Option::Some(TypeBlock::MountPropagation),
            5 => ::std::option::Option::Some(TypeBlock::Error),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TypeBlock> {
        match str {
            "Empty" => ::std::option::Option::Some(TypeBlock::Empty),
            "Ready" => ::std::option::Option::Some(TypeBlock::Ready),
            "Schedulable" => ::std::option::Option::Some(TypeBlock::Schedulable),
            "node" => ::std::option::Option::Some(TypeBlock::node),
            "MountPropagation" => ::std::option::Option::Some(TypeBlock::MountPropagation),
            "Error" => ::std::option::Option::Some(TypeBlock::Error),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TypeBlock] = &[
        TypeBlock::Empty,
        TypeBlock::Ready,
        TypeBlock::Schedulable,
        TypeBlock::node,
        TypeBlock::MountPropagation,
        TypeBlock::Error,
    ];
}

impl ::protobuf::EnumFull for TypeBlock {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TypeBlock").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TypeBlock {
    fn default() -> Self {
        TypeBlock::Empty
    }
}

impl TypeBlock {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TypeBlock>("TypeBlock")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0elonghorn.proto\x12\x06models\x1a\x1fgoogle/protobuf/timestamp.prot\
    o\"\xaa\x04\n\x0cLonghornDisk\x12\x1a\n\x08diskUUID\x18\x01\x20\x01(\tR\
    \x08diskUUID\x12(\n\x0fallowScheduling\x18\x02\x20\x01(\x08R\x0fallowSch\
    eduling\x12,\n\x11evictionRequested\x18\x03\x20\x01(\x08R\x11evictionReq\
    uested\x12\x12\n\x04path\x18\x04\x20\x01(\tR\x04path\x12*\n\x10storageAv\
    ailable\x18\x05\x20\x01(\x04R\x10storageAvailable\x12&\n\x0estorageMaxim\
    um\x18\x06\x20\x01(\x04R\x0estorageMaximum\x12(\n\x0fstorageReserved\x18\
    \x07\x20\x01(\x04R\x0fstorageReserved\x12*\n\x10storageScheduled\x18\x08\
    \x20\x01(\x04R\x10storageScheduled\x12\x12\n\x04tags\x18\t\x20\x03(\tR\
    \x04tags\x127\n\nconditions\x18\n\x20\x01(\x0b2\x17.models.ConditionsBlo\
    ckR\nconditions\x12V\n\x10scheduledReplica\x18\x0b\x20\x03(\x0b2*.models\
    .LonghornDisk.ScheduledReplicaEntryR\x10scheduledReplica\x1aC\n\x15Sched\
    uledReplicaEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x04R\x05value:\x028\x01\"\x8c\x04\n\x0cLongho\
    rnNode\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x12\n\x04zone\x18\x03\x20\x01(\tR\x04zone\
    \x12\x16\n\x06region\x18\x04\x20\x01(\tR\x06region\x12\x12\n\x04tags\x18\
    \x05\x20\x03(\tR\x04tags\x12\x18\n\x07address\x18\x06\x20\x01(\tR\x07add\
    ress\x12(\n\x0fallowScheduling\x18\x07\x20\x01(\x08R\x0fallowScheduling\
    \x128\n\x17engineManagerCPURequest\x18\x08\x20\x01(\x05R\x17engineManage\
    rCPURequest\x12:\n\x18replicaManagerCPURequest\x18\t\x20\x01(\x05R\x18re\
    plicaManagerCPURequest\x12,\n\x11evictionRequested\x18\n\x20\x01(\x08R\
    \x11evictionRequested\x125\n\x05disks\x18\x0b\x20\x03(\x0b2\x1f.models.L\
    onghornNode.DisksEntryR\x05disks\x12)\n\x07actions\x18\x0c\x20\x01(\x0b2\
    \x0f.models.ActionsR\x07actions\x1aN\n\nDisksEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12*\n\x05value\x18\x02\x20\x01(\x0b2\x14.models\
    .LonghornDiskR\x05value:\x028\x01\"\x96\x01\n\rLonghornNodes\x12(\n\x04d\
    ata\x18\x01\x20\x03(\x0b2\x14.models.LonghornNodeR\x04data\x12#\n\x05lin\
    ks\x18\x02\x20\x01(\x0b2\r.models.LinksR\x05links\x12\"\n\x0cresourceTyp\
    e\x18\x03\x20\x01(\tR\x0cresourceType\x12\x12\n\x04type\x18\x04\x20\x01(\
    \tR\x04type\"\x1b\n\x05Links\x12\x12\n\x04self\x18\x01\x20\x01(\tR\x04se\
    lf\")\n\x07Actions\x12\x1e\n\ndiskUpdate\x18\x01\x20\x01(\tR\ndiskUpdate\
    \"\xdc\x01\n\nReadyBlock\x12$\n\rlastProbeTime\x18\x01\x20\x01(\tR\rlast\
    ProbeTime\x12J\n\x12lastTransitionTime\x18\x02\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\x12lastTransitionTime\x12\x18\n\x07message\x18\x03\
    \x20\x01(\tR\x07message\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reaso\
    n\x12\x16\n\x06status\x18\x05\x20\x01(\tR\x06status\x12\x12\n\x04type\
    \x18\n\x20\x01(\tR\x04type\"\xe2\x01\n\x10SchedulableBlock\x12$\n\rlastP\
    robeTime\x18\x01\x20\x01(\tR\rlastProbeTime\x12J\n\x12lastTransitionTime\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x12lastTransitionT\
    ime\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x16\n\x06rea\
    son\x18\x04\x20\x01(\tR\x06reason\x12\x16\n\x06status\x18\x05\x20\x01(\t\
    R\x06status\x12\x12\n\x04type\x18\x06\x20\x01(\tR\x04type\"\xe7\x01\n\
    \x15MountPropagationBlock\x12$\n\rlastProbeTime\x18\x01\x20\x01(\tR\rlas\
    tProbeTime\x12J\n\x12lastTransitionTime\x18\x02\x20\x01(\x0b2\x1a.google\
    .protobuf.TimestampR\x12lastTransitionTime\x12\x18\n\x07message\x18\x03\
    \x20\x01(\tR\x07message\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reaso\
    n\x12\x16\n\x06status\x18\x05\x20\x01(\tR\x06status\x12\x12\n\x04type\
    \x18\x06\x20\x01(\tR\x04type\"\xdc\x01\n\x0fConditionsBlock\x12N\n\x10Mo\
    untPropagation\x18\x01\x20\x01(\x0b2\x1d.models.MountPropagationBlockH\0\
    R\x10MountPropagation\x88\x01\x01\x12(\n\x05Ready\x18\x02\x20\x01(\x0b2\
    \x12.models.ReadyBlockR\x05Ready\x12:\n\x0bSchedulable\x18\x03\x20\x01(\
    \x0b2\x18.models.SchedulableBlockR\x0bSchedulableB\x13\n\x11_MountPropag\
    ation\"\xed\x01\n\nErrorBlock\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04c\
    ode\x12\x16\n\x06detail\x18\x02\x20\x01(\tR\x06detail\x123\n\x05links\
    \x18\x03\x20\x03(\x0b2\x1d.models.ErrorBlock.LinksEntryR\x05links\x12\
    \x18\n\x07message\x18\x04\x20\x01(\tR\x07message\x12\x16\n\x06status\x18\
    \x05\x20\x01(\rR\x06status\x12\x12\n\x04type\x18\x06\x20\x01(\tR\x04type\
    \x1a8\n\nLinksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01*]\n\tTypeBlock\x12\t\
    \n\x05Empty\x10\0\x12\t\n\x05Ready\x10\x01\x12\x0f\n\x0bSchedulable\x10\
    \x02\x12\x08\n\x04node\x10\x03\x12\x14\n\x10MountPropagation\x10\x04\x12\
    \t\n\x05Error\x10\x05b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(LonghornDisk::generated_message_descriptor_data());
            messages.push(LonghornNode::generated_message_descriptor_data());
            messages.push(LonghornNodes::generated_message_descriptor_data());
            messages.push(Links::generated_message_descriptor_data());
            messages.push(Actions::generated_message_descriptor_data());
            messages.push(ReadyBlock::generated_message_descriptor_data());
            messages.push(SchedulableBlock::generated_message_descriptor_data());
            messages.push(MountPropagationBlock::generated_message_descriptor_data());
            messages.push(ConditionsBlock::generated_message_descriptor_data());
            messages.push(ErrorBlock::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(TypeBlock::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
